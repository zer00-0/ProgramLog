1、头文件
	1.1. Self-contained 头文件
		Tip: 
			头文件应该能够自给自足（self-contained, 也就是可以作为第一个头文件被引入），以 .h 		  结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 .inc 结尾。不允许分离出 -inl.h 头文件的做法
		
		即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上
		是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 .inc 文件扩展名。
		
		如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。
		有个例外：
			如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定
			义在实例化该模板的 .cc 文件里。
			
	1.2. #define 保护
		Tip: 
			所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: <PROJECT>_<PATH>_<FILE>_H_
			
		为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/
		baz.h 可按如下方式保护:
			#ifndef FOO_BAR_BAZ_H_
			#define FOO_BAR_BAZ_H_
			…
			#endif // FOO_BAR_BAZ_H_		
					
	1.3. 前置声明（详见https://www.zhihu.com/question/63201378）
		Tip: 
			尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
			
		定义：
			所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.	
			
		优点：
			• 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。
			• 前置声明能够节省不必要的重新编译的时间。#include 使代码因为头文件中无关的改动而被重新编译多次。
		缺点：
			• 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
			• 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API.
			  例如扩大形参类型，加个自带默认参数的模板形参等等。
			• 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。
			• 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替includes   甚至都会暗暗地改变代码的含义：	
			
		如果 #include 被 B 和 D 的前置声明替代，test() 就会调用 f(void*) . * 前置声明了不少来自头文件的
		symbol 时，就会比单单一行的 include 冗长。* 仅仅为了能前置声明而重构代码（比如用指针成员代替
		对象成员）会使代码变得更慢更复杂.	
			// b.h:
			struct B {};
			struct D : B {};

			// good_user.cc:
			#include "b.h"
			void f(B*);
			void f(void*);
			void test(D* x) { f(x); }  // calls f(B*)
		例如，如果一个类的实现者需要把这个类改个名字/换个命名空间，出于兼容性他原本可以在原命名空间里/用原名通过using来起一个别名指向新类。然而别名不能被前向声明。内网有一份代码改动一下子试图修改总计265个头文件，就是实现者为了要改这个类的名字而不得不去改所有的调用处。想一想，如果这265个文件分属于50个不同的团队，你得拿到50个人的同意才能提交这份改动，想不想打人？			
			
		结论：
			• 尽量避免前置声明那些定义在其他项目中的实体. 
			• 函数：总是使用 #include. 
			• 类模板：优先使用 #include	
			
	1.4. 内联函数
		Tip: 
			只有当函数只有 10 行甚至更少时才将其定义为内联函数.
			
		结论:
			•一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起
				来要更长, 因为有隐含的成员和基类析构函数被调用!
			•另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下,
				这些循环或 switch 语句从不被执行).
			•有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联
			
	1.5. #include的路径及顺序
		Tip: 
			使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h,项目内的 .h.
		
		项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 
			例如, google-awesome-project/src/base/logging.h 应该按如下方式包含:
			 
					#include "base/logging.h"	
			
		又如, dir/foo.cc 的主要作用是实现或测试 dir2/foo2.h 的功能, foo.cc 中包含头文件的次序如下:
		
			1. dir2/foo2.h (优先位置, 详情如下)
			2. C 系统文件
			3. C++ 系统文件
			4. 其他库的 .h 文件
			5. 本项目内 .h 文件
			
		这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时，dir/foo.cc 或 dir/foo_test.cc 的构建会立
		刻中止。因此这一条规则保证维护这些文件的人首先看到构建中止的消息而不是维护其他包的人。
		dir/foo.cc 和 dir2/foo2.h 通常位于同一目录下 (如 base/basictypes_unittest.cc 和 base/basictypes.h),
		但也可以放在不同目录下.			
		
	    按字母顺序对头文件包含进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们		
	
	小结1：	
		1. 避免多重包含是学编程时最基本的要求;
		2. 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;
		3. 内联函数的合理使用可提高代码执行效率;
		4. -inl.h 可提高代码可读性 (一般用不到吧:D);
		5. 标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放
		在一起);
		6. 包含文件的名称使用 . 和 .. 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的
		次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处:D) 的地方编
		译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证
		内部错误的及时发现了.		
		
	小结2：
		1. 原来还真有项目用 #includes 来插入文本，且其文件扩展名 .inc 看上去也很科学。
		2. Google 已经不再提倡 -inl.h 用法。
		3. 注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但
		不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建
		其类的任何对象，也不能声明成类内部的数据成员。
		4. 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的
		.cc 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。
		5. 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯		
		
2、作用域
	2.1.命名空间
		Tip: 
			鼓励在 .cc 文件内使用匿名名字空间. 使用具名的名字空间时, 其名称可基于项目名或相对路径. 禁止使用using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。
		
		2.1.1. 匿名命名空间
			• 在 .cc 文件中, 允许甚至鼓励使用匿名名字空间, 以避免运行时的命名冲突:
	
				namespace { // .cc 文件中
				// 名字空间的内容无需缩进
				enum { kUNUSED, kEOF, kERROR }; // 经常使用的符号
				bool AtEof() { return pos_ == kEOF; } // 使用本名字空间内的符号 EOF
				} // namespace	
				
				然而, 与特定类关联的文件作用域声明在该类中被声明为类型, 静态数据成员或静态成员函数, 而不是匿名名字空
				间的成员. 如上例所示, 匿名空间结束时用注释 // namespace 标识. 
			• 不要在 .h 文件中使用匿名名字空间.		
			
		2.1.2.具名命名空间
			具名的名字空间使用方式如下: 
			• 用名字空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间			
	
				// 在.h 文件中声明
				namespace mynamespace {
				// 所有声明都置于命名空间中
				// 注意不要使用缩进
				class MyClass {
				public:
				…
				void Foo();
				};
				} // namespace mynamespace
				
				// 在.cc 文件中定义
				namespace mynamespace {
				// 函数定义都置于命名空间中
				void MyClass::Foo() {
				… }
				} // namespace mynamespace	
		
			• 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体会导致不确定的问
				题, 比如不可移植. 声明标准库下的实体, 需要包含对应的头文件. 
				
			• 最好不要使用 using 指示，以保证命名空间下的所有名称都可以正常使用.
				// 禁止 —— 污染命名空间
					using namespace foo;
					
			• 在 .cc 文件, .h 文件的函数, 方法或类中, 可以使用 using 声明。
				// 允许: .cc 文件中
				// .h 文件的话, 必须在函数, 方法或类的内部使用
					using ::foo::bar;
					
			• 在 .cc 文件, .h 文件的函数, 方法或类中, 允许使用命名空间别名.	
				// 允许: .cc 文件中
				// .h 文件的话, 必须在函数, 方法或类的内部使用
					namespace fbz = ::foo::bar::baz;
					
				// 在 .h 文件里
					namespace librarian {
					//以下别名在所有包含了该头文件的文件中生效。
					namespace pd_s = ::pipeline_diagnostics::sidetable;
					inline void my_inline_function() {
						// namespace alias local to a function (or method).
						namespace fbz = ::foo::bar::baz;
						...
					}} // namespace librarian	
	
				注意在.h 文件的别名对包含了该头文件的所有人可见，所以在公共头文件（在项目外可用）以及它们
				递归包含的其它头文件里，不要用别名。毕竟原则上公共 API 要尽可能地精简。
			• 禁止用内联命名空间
	
	2.2.嵌套类
		Tip: 
			当公有嵌套类作为接口的一部分时, 虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于2.1. 名字空间 内是更好的选择.
		结论:
			不要将嵌套类定义成公有, 除非它们是接口的一部分, 比如, 嵌套类含有某些方法的一组选项.
	
	2.3.非成员函数、静态成员函数和全局函数
		Tip: 
			使用静态成员函数或命名空间内的非成员函数, 尽量不要用未封装的全局函数
	
		结论:
		•有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非
		 成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享
		 任何静态数据的静态成员函数而创建类, 不如使用2.1. 命名空间。
		
		•定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员
		 函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.
		
		•如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 namespaces‘或 ‘‘static‘ 链接关键字
		 (如 static int Foo() {...}) 限定其作用域.	
	
	2.4.局部变量
		Tip: 
			将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
			
			C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使
			得代码浏览者更容易定位变量声明的位置,了解变量的类型和初始值.特别是，应使用初始化的方式替代声明再赋值	
				
			Warning: 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数.
		
		
	2.5.静态与全局变量
		Tip: 
			禁止使用 class 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。		
	
		•静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型(POD : 
		 Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。		
		
		•静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是不确定的，甚至随着构建变化而变化，导致难以发现的 bug.
		 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数不涉及
		（比如 getenv() 或 getpid()）不涉及任何全局变量。（函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确
		 定义的，而且只会在指令执行到它的声明那里才会发生。）
		 
		•同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 main() 返回还是对 exit() 
		 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。
		
		•改善以上析构问题的办法之一是用 quick_exit() 来代替 exit() 并中断程序。它们的不同之处是前者不会执行
		 任何析构，也不会执行 atexit() 所绑定的任何 handlers. 如果您想在执行 quick_exit() 来中断时执行某 handler
		 （比如刷新 log），您可以把它绑定到 _at_quick_exit(). 如果您想在 exit() 和 quick_exit() 都用上该 handler, 都
		 绑定上去。
		
		综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 constchar [])。
		
		如果您确实需要一个 class 类型的静态或全局变量，可以考虑在 main() 函数或 pthread_once() 内初始化一个
		指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。
		
		
		小结1：
		1. cc 中的匿名名字空间可避免命名冲突, 限定作用域, 避免直接使用 using 关键字污染命名空间;
		2. 嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 public;
		3. 尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;
		4. 多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug.
		5. 作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.
		
		小结2：
		1. 注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。
		2. 匿名名字空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。
		3. 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体
		系结构重要的概念「局部性（locality）」。
		4. 注意别在循环犯大量构造和析构的低级错误。		
	
3.类
	3.1. 构造函数的职责
		Tip: 
			不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化)
	
		结论:
			构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化,
			考虑使用明确的 Init() 方法或使用工厂模式
		
	3.2.初始化
		Tip: 
			如果类中定义了成员变量, 则必须在类中为每个类提供初始化函数或定义一个构造函数. 若未声明构造函数, 
			则编译器会生成一个默认的构造函数, 这有可能导致某些成员未被初始化或被初始化为不恰当的值.
		
		结论:
			•简单的初始化用类成员初始化完成, 尤其是当一个成员变量要在多个构造函数里用相同的方式初始化的时候.
			•如果你的类中有成员变量没有在类里面进行初始化, 而且没有提供其它构造函数, 你必须定义一个 (不带参数的) 默认构造函数. 把对象的内部状态初始化成一致/ 有效的值无疑是更合理的方式.
				这么做的原因是: 如果你没有提供其它构造函数, 又没有定义默认构造函数, 编译器将为你自动
				生成一个. 编译器生成的构造函数并不会对对象进行合理的初始化.
				如果你定义的类继承现有类, 而你又没有增加新的成员变量, 则不需要为新类定义默认构造函数	
		
	3.3.显式构造函数
		Tip: 
			对单个参数的构造函数使用 C++ 关键字 explicit.
		
		通常, 如果构造函数只有一个参数, 可看成是一种隐式转换. 打个比方, 如果你定义了 Foo::Foo(string
		name), 接着把一个字符串传给一个以 Foo 对象为参数的函数, 构造函数 Foo::Foo(string name) 将被
		调用, 并将该字符串转换为一个 Foo 的临时对象传给调用函数（如父类转换成子类类型）
		除单参数构造函数外, 这一规则也适用于除第一个参数以外的其他参数都具有默认参数的构造函数
		
		
		结论:
			所有单参数构造函数都必须是显式的. 在类定义中, 将关键字 explicit 加到单参数构造函数前: explicit
			Foo(string name);
	
	3.4. 可拷贝类型与可移动类型
		Tip: 
			如果你的类型需要, 就让它们支持拷贝/ 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.
		
		定义：
			可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 	
			同时不改变源对象的值，（ string 类型就是一个可拷贝类型的例子.）
			
			可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的)（std::unique_ptr<int> 就是一个可移动但不可复制的对象的例子）
			移动操作允许隐式且高效地将源数据转移出右值对象
		
		结论:
			如果需要就让你的类型可拷贝/ 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一
			眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值
			操作的定义. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造
			函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类
			型设置为只可移动并定义移动的两个操作.
			
				建议通过 = default 定义拷贝和移动操作. 定义非默认的移动操作目前需要异常. 时刻记得检
				测默认操作的正确性. 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操
				作或者拷贝/ 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复
				制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类
				实现.
				如果你的类不需要拷贝/ 移动操作, 请显式地通过 = delete 或其他手段禁用之		
		
		
	3.5.委派与继承构造函数
		Tip: 
			在能够减少重复代码的情况下使用委派和继承构造函数
		
		定义:
			委派和继承构造函数是由 C++11 引进为了减少构造函数重复代码而开发的两种不同的特性. 通过特殊的
			初始化列表语法, 委派构造函数允许类的一个构造函数调用其他的构造函数. 
			例如: 
					X::X(const string& name) : name_(name) {
					...
					}X::X() : X("") { }		
		
		结论:
			只在能够减少冗余代码, 提高可读性的前提下使用委派和继承构造函数. 如果派生类有新的成员变量, 那么
			使用继承构造函数时要小心. 如果在派生类中对成员变量使用了类内部初始化的话, 继承构造函数还是适
			用的.		
		
		
	3.6.结构体与类
		Tip: 
			当且仅当只有数据时使用 struct, 其它一概使用 class.
		
		为了和 STL 保持一致, 对于仿函数和 trait 特性可以不用 class 而是使用 struct.
		注意: 类和结构体的成员变量使用不同的命名规则.
		
	3.7.继承
		Tip: 
			使用组合 (composition, YuleFox 注: 这一点也是 GoF 在 <<Design Patterns>> 里反复强调的) 
			常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承
		
		结论:
			所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.
			不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a”
			情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.
			必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意数据成员在
			任何情况下都必须是私有的.
			当重载一个虚函数, 在衍生类中把它明确的声明为 virtual. 理论依据: 如果省略 virtual 关键字, 代码阅
			读者不得不检查所有父类, 以判断该函数是否是虚函数.		
		
	3.8.多重继承
		Tip: 
			真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的纯接口类
		
		结论:
			只有当所有父类除第一个外都是纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以
			Interface 为后缀.		
	
	3.9.接口（interface具体实现https://www.coder.work/article/574550）
		Tip: 
			接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制)

		定义:
			当一个类满足以下要求时, 称之为纯接口:
				• 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).
				• 没有非静态数据成员. 
				• 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected. 
				• 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.
				
			接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明
			虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数)		
		
	3.10.运算符重载
		Tip:
			除少数特定环境外，不要重载运算符

		结论：
			一般不要重载运算符. 尤其是赋值操作 (operator=) 比较诡异, 应避免重载. 如果需要的话, 可以定义类似
			Equals(), CopyFrom() 等函数.
			然而, 极少数情况下可能需要重载运算符以便与模板或 “标准” C++ 类互操作 (如 operator<<(ostream&,
			const T&)). 只有被证明是完全合理的才能重载, 但你还是要尽可能避免这样做. 尤其是不要仅仅为了在
			STL 容器中用作键值就重载 operator== 或 operator<; 相反, 你应该在声明容器的时候, 创建相等判断和
			大小比较的仿函数类型
	
	3.11.存取控制
		Tip:
		将 所有 数据成员声明为 private, 并根据需要提供相应的存取函数. 例如, 某个名为 foo_ 的变量, 其取值函数
		是 foo(). 还可能需要一个赋值函数 set_foo().
			特例是, 静态常量数据成员 (一般写做 kFoo) 不需要是私有成员.
			一般在头文件中把存取函数定义成内联函数.		
		
	3.12.声明顺序
		Tip: 
			在类中使用特定的声明顺序: public: 在 private: 之前, 成员函数在数据成员 (变量) 前;

		类的访问控制区段的声明顺序依次为: public:, protected:, private:. 如果某区段没内容, 可以不声明.
		每个区段内的声明通常按以下顺序: 
			• typedefs 和枚举
			• 常量
			• 构造函数
			• 析构函数
			• 成员函数, 含静态成员函数
			• 数据成员, 含静态数据成员
			
		友元声明应该放在 private 区段. 如果用宏 DISALLOW_COPY_AND_ASSIGN 禁用拷贝和赋值, 应当将其置
		于 private 区段的末尾, 也即整个类声明的末尾	
		
		.cc 文件中函数的定义应尽可能和声明顺序一致.
		
		不要在类定义中内联大型函数. 通常, 只有那些没有特别意义或性能要求高, 并且是比较短小的函数才能被定义为
		内联函数.

		
		
		
		3总结：
			1. 不在构造函数中做太多逻辑相关的初始化;
			2. 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自
			行提供默认构造函数;
			3. 为避免隐式转换, 需将单参数构造函数声明为 explicit;
			4. 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现;
			5. 仅在作为数据集合时使用 struct;
			6. 组合 > 实现继承 > 接口继承 > 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这
			样做;
			7. 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;
			8. 接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非
			静态数据成员, 不提供构造函数, 提供的话，声明为 protected;
			9. 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;
			10. 存取函数一般内联在头文件中;
			11. 声明次序: public -> protected -> private;
			12. 函数体尽量短小, 紧凑, 功能单一;		
		
4.函数
	4.1.参数顺序
		Tip：
			函数的参数顺序为: 输入参数在先, 后跟输出参数.
		
		C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前		
		
	4.2.编写简短函数
		Tip: 倾向编写简短, 凝练的函数（太长考虑分割函数）
		
		我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影
		响程序结构的前提下对其进行分割.
		
		即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题. 甚至导致难以发现的 bug. 使函数
		尽量简短, 便于他人阅读和修改代码.
		
		在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用/ 调试困难, 或者你
		需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数	
		
	4.3.引用参数
		Tip：
			所有按引用传递的参数必须加上 const
			
		结论：
			函数参数列表中, 所有引用参数都必须是 const:
				void Foo(const string &in, string *out);
				
			事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap().

			有时候, 在输入形参中用 const T* 指针比 const T& 更明智. 比如:
				可能会传递空指针.
				函数要把指针或对地址的引用赋值给输入形参.
			
			总而言之, 大多时候输入形参往往是 const T&. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑.		
		
	4.4.函数重载
		Tip：
			若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数
		
		定义：
			你可以编写一个参数类型为 const string& 的函数, 然后用另一个参数类型为 const char* 的函数对其进行重载:
				class MyClass {
					public:
					void Analyze(const string &text);
					void Analyze(const char *text, size_t textlen);
				};
		结论：
			如果打算重载一个函数, 可以试试在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append(). 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.		
		
	4.5.缺省参数
		Tip：
			只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.
		
		总结：
			对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 void f(int n = counter++); 这样的代码.)

			在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.		
		
	4.6. 函数返回类型后置语法
		Tip:
			只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.（使用auto）
		
		C++11 引入了这一新的形式. 现在可以在函数名前使用 auto 关键字, 在参数列表之后后置返回类型. 例如:
				auto foo(int x) -> int;
			与
				int foo(int x);
		后置返回类型为函数作用域. 对于像 int 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.
	
		结论：
			在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码.		
		
5.来自google的奇技
	
	5.1.所有权与智能指针
		Tip: 
			动态分配出的对象最好有单一且固定的所有主（onwer）, 且通过智能指针传递所有权（ownership）.
		
		定义：
			所有权是一种登记／管理动态内存和其它资源的技术。动态分配出的对象的所有主是一个对象或函数，后
			者负责确保当前者无用时就自动销毁前者。所有权有时可以共享，那么就由最后一个所有主来负责销毁
			它。甚至也可以不用共享，在代码中直接把所有权传递给其它对象。
			其实您可以把智能指针当成一个重载了 * 和 -> 的「对象」来看。智能指针类型被用来自动化所有权的登
			记工作，来确保执行销毁义务到位。std::unique_ptr 是 C++11 新推出的一种智能指针类型，用来表示
			动态分配出的对象的「独一无二」所有权；当 std::unique_ptr 离开作用域，对象就会被销毁。不能复
			制 std::unique_ptr, 但可以把它移动（move）给新所有主。std::shared_ptr 同样表示动态分配对象的
			所有权，但可以被共享，也可以被复制；对象的所有权由所有复制者共同拥有，最后一个复制者被销毁
			时，对象也会随着被销毁。		
		
		决定：
			如果必须使用动态分配，倾向于保持分配者的所有权。如果其他地方要使用这个对象，最好传递它的拷
			贝，或者传递一个不用改变所有权的指针或引用。倾向于使用 std::unique_ptr 来明确所有权传递，例
			如：
				std::unique_ptr<Foo> FooFactory();
				void FooConsumer(std::unique_ptr<Foo> ptr);
			
			避 免 使 用 共 享 所 有 权。 如 果 对 性 能 要 求 很 高， 并 且 操 作 的 对 象 是 不 可 变 的 （比 如 说
			std::shared_ptr<const Foo> ），这时可以用共享所有权来避免昂贵的拷贝操作。如果确实要使用
			共享所有权，倾向于使用 std::shared_ptr 。
			
			不要在新代码中使用 scoped_ptr `` ，除非你必须兼容老版本的 C++。总是用 ``std::unique_ptr 代 替 std::auto_ptr 。		
		
		
	5.2.cpplint（https://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py）
		Tip: 
			使用 cpplint.py 检查风格错误.
		
		cpplint.py 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍
		然是一个非常有用的工具. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错。
		某些项目会指导你如何使用他们的项目工具运行 cpplint.py. 如果你参与的项目没有提供, 你可以单独下载
		cpplint.py.
		
		总结：
			1. 把智能指针当成对象来看待的话，就很好领会它与所指对象之间的关系了。
			2. 原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊。
			3. scoped_ptr 和 auto_ptr 已过时。现在是 shared_ptr 和 uniqued_ptr 的天下了。
			4. 按本文来说，似乎除了智能指针，还有其它所有权机制，值得留意。
			5. Arch Linux 用户注意了，AUR 有对 cpplint 打包。		
	
6.C++其他特性
	
	6.1.引用参数
		Tip: 所有按引用传递的参数必须加上 const.（同4.3）
		
	6.2.右值引用（https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8）
		Tip: 
			只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 std::forward
		
		定义:
			左值为确定的有内存分配的值，右值为非左值（大部分情况为没有内存分配）
			右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, void
			f(string&& s); 声明了一个其参数是一个字符串的右值引用的函数
		
		结论:
			只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数. 你可能会使
			用 std::move 来表示将值从一个对象移动而不是复制到另一个对象.
		
	6.3.变长数组和alloc()
		Tip：我们不允许使用变长数组和 alloc().
			
			alloc()根据数据大小动态分配堆栈内存，容易内存越界
		结论:
			改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr<T[]>.

	6.4.右元
		Tip：我们允许合理的使用友元类及友元函数.
		
		通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 FooBuilder 声明为 Foo 的友元, 以便 FooBuilder 正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.

		友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 public, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.		

	6.5.异常
		Tip：我们不使用 C++ 异常.
		
		结论:

			从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.

			鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.		

	6.6.运行时类型识别
		Tip：我们禁止使用 RTTI.
		
		结论:
			RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其
			他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类
			型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:
			
				虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.
				
				如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在
				对象之外进行类型判断.
			
			如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在
			这种情况下, 使用 dynamic_cast 也是一种替代方案		

			基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:
				if (typeid(*data) == typeid(D1)) {
				...
				} else if (typeid(*data) == typeid(D2)) {
				...
				} else if (typeid(*data) == typeid(D3)) {
				...
				
			一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到
			并修改所有受影响的代码块.
			不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继
			承体系. 而且, 这些方案会掩盖你的真实意图.
	6.7.类型转换
		Tip: 
			使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式
		
		结论:
			不要使用 C 风格类型转换. 而应该使用 C++ 风格. 
				• 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.
				• 用 const_cast 去掉 const 限定符. 
				• 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 
				  仅在你对所做一切了然于心时使用.
			至于 dynamic_cast 参见6.6. 运行时类型识别.
		
	6.8.流
		Tip: 只在记录日志时使用流.
		
		定义:
			流用来替代 printf() 和 scanf()
		结论:
			不要使用流, 除非是日志接口需要. 使用 printf 之类的代替.
			使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流
			
		流与printf + read/write，每一种方式都是各有利弊, “没有最好, 只有更适合”. 
		简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 printf + read/write
		
	6.9.前置自增与自减
		Tip: 
			对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, （--i）自减运算符
		
		结论:
			对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).
		
	6.10.const用法
		Tip: 
			我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。
		
		结论:
			const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强
			烈建议在任何可能的情况下使用 const: 
				• 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const. 
				• 尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const
				  函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const. 
				• 如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.
			
			然而, 也不要发了疯似的使用 const. 像 const int * const * const x; 就有些过了, 虽然它非常精确
			的描述了常量 x. 关注真正有帮助意义的信息: 前面的例子写成 const int** x 就够了.
			关键字 mutable 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.
			const 的位置:
			有人喜欢 int const *foo 形式, 不喜欢 const int* foo, 他们认为前者更一致因此可读性也更好: 遵循
			了 const 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消
			大部分你原本想保持的一致性. 将 const 放在前面才更易读, 因为在自然语言中形容词 (const) 是在名词
			(int) 之前.
			这是说, 我们提倡但不强制 const 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把
			const 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)		
	
	6.11.constexpr用法（表示该变量在编译器可以计算出来，const未区分）
		Tip: 
			在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。const只限制只读（避免双重语义）
			（http://c.biancheng.net/view/7807.html）
		定义:
			变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函
			数也可以被声明成 constexpr, 以用来定义 constexpr 变量。	
		
		结论: 
			靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真常量以
			及支持常量的函数。避免复杂的函数定义，以使其能够与 constexpr 一起使用。千万别痴心妄想地想靠 constexpr 来强制代码「内联」。		
	
	6.12.整型
		Tip: 
			C++ 内建整型中, 仅使用 int. 如果程序中需要不同大小的变量, 可以使用 <stdint.h> 中长度精确的整型, 如
			int16_t. 如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 int64_t. 此外要留意，哪怕您
			的值并不会超出int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。		
		
		定义:
			C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64
			位.
		
		结论:
			<stdint.h> 定义了 int16_t, uint32_t, int64_t 等整型, 在需要确保整型大小时可以使用它们代替
			short, unsigned long long 等. 在 C 整型中, 只使用 int. 在合适的情况下, 推荐使用标准类型如 size_t
			和 ptrdiff_t.
			
			如果已知整数不会太大, 我们常常会使用 int, 如循环计数. 在类似的情况下使用原生类型 int. 你可以认
			为 int 至少为 32 位, 但不要认为它会多于 32 位. 如果需要 64 位整型, 用 int64_t 或 uint64_t.
			对于大整数, 使用 int64_t.

			不要使用 uint32_t 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补
			码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.
			如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型
			越大越好。
			
			小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 int 与 unsigned int 运算时，
			前者被提升为 unsigned int 而有可能溢出），总有意想不到的后果。
			关于无符号整数:		
		
	6.13. 64位下的可移植性
		Tip: 
			代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:
			
		类型						不要使用		 		使用 					备注
		void * (或其他指针类型)        %lx 			    	%p
		int64_t 					%qd,%lld 				%"PRId64"
		uint64_t 				%qu, %llu, %llx 		%"PRIu64", %"PRIx64"
		size_t							%u 	   	 		%"PRIuS", %"PRIxS" 		 C99 规定 %zu
		ptrdiff_t 						%d 				%"PRIdS"				 C99 规定 %zd		
		
		• 记住 sizeof(void *) != sizeof(int). 如果需要一个指针大小的整数要用 intptr_t. 
		• 你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序
		  保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 int64_t/uint64_t 成员的类/结构体, 缺省都以 8 字节
		  在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多
		  数编译器都允许调整结构体对齐. gcc 中可使用 __attribute__((packed)). MSVC 则提供了 #pragma pack()
		  和 __declspec(align()) (YuleFox 注, 解决方案的项目属性里也可以直接设置).
		• 创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:
			  int64_t my_value = 0×123456789LL;
			  uint64_t my_mask = 3ULL << 48;
		• 如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 #ifdef _LP64 指令来切分 32/64 位代码. (尽量不
		  要这么做, 如果非用不可, 尽量使修改局部化)		
	6.14. 预处理宏
		Tip: 
			使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之
		
		下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:
			• 不要在 .h 文件中定义宏. 
			• 在马上要使用时才进行 #define, 使用后要立即 #undef. 
			• 不要只是对已经存在的宏使用 #undef，选择一个不会冲突的名称；
			• 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为. 
			• 不要用 ## 处理函数，类和变量的名字。		
		
	6.15 0 ，nullptr和NULL
		Tip: 
			• 整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 '\0'.整数用 0, 实数用 0.0,     
			  这一点是毫无争议的.
			• 对于指针 (地址值), 到底是用 0, NULL 还是 nullptr. C++11 项目用 nullptr; C++03 项目则用 NULL, 毕竟它
			  看起来像指针。实际上，一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL)
			  就和 sizeof(0) 不一样。
			• 字符 (串) 用 '\0', 不仅类型正确而且可读性好		
		
	6.16. sizeof
		Tip: 
			尽可能用 sizeof(varname) 代替 sizeof(type).
				int a； sizeof（a） 与   sizeof（int）
			使用 sizeof(varname) 是因为当代码中变量类型改变时会自动更新. 您或许会用 sizeof(type) 处理不涉及任
			何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。
		
	6.17. auto
		Tip: 
			用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。
		
		结论：
			auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 
			auto 变量。
			auto 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda
			表达式里。		
	6.18. 列表初始化
		Tip: 你可以用列表初始化。
			 永远别列表初始化 auto 变量。
		
	6.19. lambda表达式
		Tip: 
			适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。
		
		定义：
			Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：
				std::sort(v.begin(), v.end(), [](int x, int y) {
					return Weight(x) < Weight(y);
				});		
		
		结论：
			• 按 标准 小用 lambda 表达式怡情。
			• 禁用默认捕获，捕获都要显式写出来。打比方，比起 [=](int x) {return x + n;}, 您该写成 [n](int x)
			  {return x + n;} 才对，这样读者也好一眼看出 n 是被捕获的值。
			• 匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对
			  象），或改用函数。
			• 如果可读性更好，就显式写出 lambd 的尾置返回类型，就像 auto.		
		
	6.20. 模板编程
		Tip: 不要使用复杂的模板编程
		
		结论:
			• 模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基
			  础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉
			• 在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是
			  否能够读懂并且能够维护你写的模板代码. 或者一个非 c++ 程序员和一些只是在出错的时候偶尔看一下代码的
			  人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元
			  函数, 又或者表达式模板, 或者依赖 SFINAE, 或者 sizeof 的 trick 手段来检查函数是否重载, 那么这说明你模板
			  用的太多了, 这些模板太复杂了, 我们不推荐使用
			• 如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里
			  面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用
			  模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代
			  码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为
			  这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理
			  解, 并且用户很容易知道如何修改这些错误		
		
		
	6.21. Boost库
		Tip: 
			只使用 Boost 中被认可的库
		
		结论:
			为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前
			允许使用以下库: 
				• Call Traits : boost/call_traits.hpp
				• Compressed Pair : boost/compressed_pair.hpp
				• <The Boost Graph Library (BGL) : boost/graph, except serialization (adj_list_serialize.
				hpp) and parallel/distributed algorithms and data structures(boost/graph/parallel/* and boost/
				graph/distributed/*) • Property Map : boost/property_map.hpp
				• The part of Iterator that deals with defining iterators: boost/iterator/iterator_adaptor.hpp,
				boost/iterator/iterator_facade.hpp, and boost/function_output_iterator.hpp
				• The part of Polygon that deals with Voronoi diagram construction and doesn’t depend on the rest
				of Polygon: boost/polygon/voronoi_builder.hpp, boost/polygon/voronoi_diagram.hpp, and
				boost/polygon/voronoi_geometry_type.hpp
				• Bimap : boost/bimap
				• Statistical Distributions and Functions : boost/math/distributions
				• Multi-index : boost/multi_index
				• Heap : boost/heap
				• The flat containers from Container: boost/container/flat_map, and boost/container/flat_set
			
			我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.
			以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：
				• Pointer Container : boost/ptr_container, 改用 std::unique_ptr
				• Array : boost/array.hpp, 改用 std::array		
		
	6.22. C++11
		Tip: 
			适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。
		
		以下特性最好不要用：
			• 尾置返回类型，比如用 auto foo() -> int 代替 int foo(). 为了兼容于现有代码的声明风格。
			• 编译时合数 <ratio>, 因为它涉及一个重模板的接口风格。
			• <cfenv> 和 <fenv.h> 头文件，因为编译器尚不支持。
			• 默认 lambda 捕获。		
		
	6总结：		
		1. 实际上，缺省参数会改变函数签名的前提是改变了它接收的参数数量，比如把 void a() 改成 void a(int b =
		   0), 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这
		   终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。
		2. 此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。
		3. 我还发现 滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。
		4. friend 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部
		   写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 .cc 文件加以定义。
		5. 本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那
		   么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。
		6. 由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，
		   即的数据成员之后，参考声明顺序 。
		7. 对使用 C++ 异常处理应具有怎样的态度？ 非常值得一读。
		8. 注意初始化 const 对象时，必须在初始化的同时值初始化。
		9. 用断言代替无符号整型类型，深有启发。
		10. auto 在涉及迭代器的循环语句里挺常用。
		11. Should the trailing return type syntax style become the default for new C++11 programs? 讨论了 auto 
		   与尾置返回类型一起用的全新编码风格，值得一看。		
		
		
7、命名约定

	7.1. 通用命名规则
		Tip: 
			函数命名，变量命名，文件命名要有描述性；少用缩写。
			尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。
		
	7.2. 文件命名
		Tip: 
			文件名要全部小写, 可以包含下划线 (_) 或连字符 (-). 按项目约定来. 如果并没有项目约定，”_” 更好。
			可接受的文件命名:
				* my_useful_class.cc
				* my-useful-class.cc
				* myusefulclass.cc
				* muusefulclass_test.cc // ``_unittest`` 和 ``_regtest`` 已弃用。		
		
			• C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾，参见1.1. Self-contained 头
			  文件。
			• 不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 db.h.
			• 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如
			  foo_bar.h 和 foo_bar.cc, 对应于类 FooBar.
			• 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中		
		
	7.3. 类型命名
		Tip: 
			类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
			所有类型命名——类, 结构体, 类型定义 (typedef), 枚举——均使用相同约定. 例如:
				// classes and structs
				class UrlTable { ...
				class UrlTableTester { ...
				struct UrlTableProperties { ...
				// typedefs
				typedef hash_map<UrlTableProperties *, string> PropertiesMap;
				// enums
				enum UrlTableErrors { ...
		
	7.4. 变量命名
		Tip: 
			变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，
			如:
				a_local_variable, a_struct_data_member, a_class_data_member_.
		
	7.5. 常量命名
		Tip: 
			在全局或类里的常量名称前加 k: kDaysInAWeek. 且除去开头的 k 之外每个单词开头字母均大写。
			所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. k 后接大写字母开头的单词:
				const int kDaysInAWeek = 7;
			这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。
		
	7.6. 函数命名
		Tip: 
			常 规 函 数 使 用 大 小 写 混 合, 取 值 和 设 值 函 数 则 要 求 与 变 量 名 匹 配: MyExcitingFunction(),MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable().
		
		常规函数:
			函数名的每个单词首字母大写, 没有下划线。
			如果您的某函数出错时就要直接 crash, 那么就在函数名加上 OrDie. 但这函数本身必须集成在产品代码
			里，且平时也可能会出错。
				AddTableEntry()
				DeleteUrl()
				OpenFileOrDie()		

		取值和设值函数:
			取值（Accessors）和设值（Mutators）函数要与存取的变量名匹配. 这儿摘录一个类, num_entries_ 是该
			类的实例变量:
				class MyClass {
				public:
				...
				int num_entries() const { return num_entries_; }
				void set_num_entries(int num_entries) { num_entries_ = num_entries; }
				private:
				int num_entries_;
				};
			其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其
			返回值, 小写命名就可以接受		
		
	7.7. 命名空间命名
		Tip: 
			命名空间用小写字母命名, 并基于项目名称和目录结构: google_awesome_project
		
	7.8. 枚举命名
		Tip: 
			枚举的命名应当和常量 或宏 一致: kEnumName 或是 ENUM_NAME
		
		单独的枚举值应该优先采用常量的命名方式，但宏方式命名也可以接受，枚举名 UrlTableErrors (和 AlternateUrlTab）
			enum UrlTableErrors {
				kOK = 0,
				kErrorOutOfMemory,
				kErrorMalformedInput,
			};
			enum AlternateUrlTableErrors {
				OK = 0,
				OUT_OF_MEMORY = 1,
				MALFORMED_INPUT = 2,
			};
	
		这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常
		量风格, 除非宏风格确实会产生编译期问题
	
	7.9. 宏命名
		Tip: 你并不打算使用宏, 对吧? 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN
	
		参考预处理宏; 通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:
			#define ROUND(x) ...
			#define PI_ROUNDED 3.0
	
	7.10. 命名规则的特例
		Tip: 
			如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.
	
		bigopen():			函数名, 参照 open() 的形式
		uint:				typedef
		bigpos:				struct 或 class, 参照 pos 的形式
		sparse_hash_map:	STL 相似实体; 参照 STL 命名约定
		LONGLONG_MAX:		常量, 如同 INT_MAX
	
8.注释
	8.1 注释风格
		Tip: 使用 // 或 /* */, 统一就好
	
	8.2 文件注释
		Tip: 
			在每一个文件开头加入版权公告, 然后是文件内容描述.
		法律公告和作者信息:
		每个文件都应该包含以下项, 依次是: 
			• 版权声明 (比如, Copyright 2008 Google Inc.) 
			• 许可证. 为项目选择合适的许可证版本 (比如, Apache 2.0, BSD, LGPL, GPL)
			• 作者: 标识文件的原始作者.
			
		如果你对原始作者的文件做了重大修改, 将你的信息添加到作者信息里. 这样当其他人对该文件有疑问时可以知道该联系谁.
		
		文件内容:
		紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容.
		通常, .h 文件要对所声明的类的功能和用法作简单说明. .cc 文件通常包含了更多的实现细节或算法技巧讨论, 
		如果你感觉这些实现细节或算法技巧讨论对于理解 .h 文件有帮助, 可以将该注释挪到 .h, 并在 .cc中指出文档在 .h.
		不要简单的在 .h 和 .cc 间复制注释. 这种偏离了注释的实际意义.		
			
	8.3 类注释
		Tip: 
			每个类的定义都要附带一份注释, 描述类的功能和用法
	
			// Iterates over the contents of a GargantuanTable. Sample usage:
			// GargantuanTable_Iterator* iter = table->NewIterator();
			// for (iter->Seek("foo"); !iter->done(); iter->Next()) {
			// process(iter->key(), iter->value());
			// }
			// delete iter;
			class GargantuanTable_Iterator {
			...
			};
			
		如果你觉得已经在文件顶部详细描述了该类, 想直接简单的来上一句 “完整描述见文件顶部” 也不打紧, 但务必确
		保有这类注释.
		
		如果类有任何同步前提, 文档说明之. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的
		规则和常量使用.		
	
	8.4 函数注释
		Tip: 
			函数声明处注释描述函数功能; 定义处描述函数实现
	
		函数声明:
			注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open
			the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.
			函数声明处注释的内容: 
				• 函数的输入输出. 
				• 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 
				• 如果函数分配了空间, 需要由调用者释放.
				• 参数是否可以为 NULL.
				• 是否存在函数使用上的性能隐患.
				• 如果函数是可重入的, 其同步前提是什么?		

				// Returns an iterator for this table. It is the client's
				// responsibility to delete the iterator when it is done with it,
				// and it must not use the iterator once the GargantuanTable object
				// on which the iterator was created has been deleted.
				//
				// The iterator is initially positioned at the beginning of the table.
				//
				// This method is equivalent to:
				// Iterator* iter = table->NewIterator();
				// iter->Seek("");
				// return iter;
				// If you are going to immediately seek to another place in the
				// returned iterator, it will be faster to use NewIterator()
				// and avoid the extra seek.
				Iterator* GetIterator() const;	
	
			但也要避免罗罗嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为
			已经暗含其中了:
				// Returns true if the table cannot hold any more entries.
				bool IsTableFull();
			
			注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的
			注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么.
			如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的		
	
		函数定义:
			每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如
			此实现的理由, 为什么前半部分要加锁而后半部分不需要.
			不要 从 .h 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在
			如何实现上.
	
	8.5. 变量注释
		Tip: 
			通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.
	
		类数据成员:
			每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 NULL 或 -1 等警
			戒值, 须加以说明. 比如:
				private:
				// Keeps track of the total number of entries in the table.
				// Used to ensure we do not go over the limit. -1 means
				// that we don't yet know how many entries the table has.
				int num_total_entries_;
				
		全局变量:
			和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如:
				// The total number of tests cases that we run through in this regression test.
				const int kNumTestCases = 6;		
	
	8.6. 实现注释
		Tip: 
			对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.
	
		代码前注释:
			巧妙或复杂的代码段前要加注释. 比如:
				// Divide result by two, taking into account that x
				// contains the carry from the add.
				for (int i = 0; i < result->size(); i++) {
					x = (x << 8) + (*result)[i];
					(*result)[i] = x >> 1; x &= 1; 
				}
				
		行注释:
			比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:
				// If we have enough memory, mmap the data portion too.
				mmap_budget = max<int64>(0, mmap_budget - index_->length());
				if (mmap_budget >= data_size_ && !MmapData(mmap_chunk_bytes, mlock))
					return; // Error already logged.	
	
			注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.
			如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:
			DoSomething(); 					// Comment here so the comments line up.
			DoSomethingElseThatIsLonger();  // Comment here so there are two spaces between
											// the code and the comment.
			{ 								// One space before comment when opening a new scope is allowed,
											// thus the comment lines up with the following comments and code.
			DoSomethingElse(); 				// Two spaces before line comments normally.
			}	
	
		NULL, true/false, 1, 2, 3...:
			向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比:
				Warning:
					bool success = CalculateSomething(interesting_value,
					10,
					false,
					NULL); // What are these arguments??	
	
				和:
					bool success = CalculateSomething(interesting_value,
					10, 		// Default base value.
					false, 		// Not the first time we're calling this.
					NULL); 		// No callback	
	
		或使用常量或描述性变量:
			const int kDefaultBaseValue = 10;
			const bool kFirstTimeCalling = false;
			Callback *null_callback = NULL;
			bool success = CalculateSomething(interesting_value,
											  kDefaultBaseValue,
											  kFirstTimeCalling,
											  null_callback);		

		不允许:
			注意 永远不要 用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:
				Warning:
					// 现在, 检查 b 数组并确保 i 是否存在,
					// 下一个元素是 i+1.
					... // 天哪. 令人崩溃的注释.	
	
	8.7 标点，拼写与语法
		Tip: 
			注意标点, 拼写和语法; 写的好的注释比差的要易读的多.
		
		注释的通常写法是包含正确大小写和结尾句号的完整语句. 短一点的注释 (如代码行尾注释) 可以随意点, 依然要
		注意风格的一致性. 完整的语句可读性更好, 也可以说明该注释是完整的, 而不是一些不成熟的想法.
		虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法
		对此会有所帮助.
	
	8.8. TODO注释
		Tip: 
			对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释.
		
		TODO 注释要使用全大写的字符串 TODO, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可
		选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO
		注释并不意味着你要自己来修正.
			// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
			// TODO(Zeke) change this to use relations.
			
		如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个
		明确的事项 (“Remove this code when all clients can handle XML responses.”).		
			
	8.9 弃用注释
		Tip: 
			通过弃用注释（DEPRECATED comments）以标记某接口点（interface points）已弃用。
	
		您可以写上包含全大写的 DEPRECATED 的注释，以标记某接口为弃用状态。注释可以放在接口声明前，或者同一行。
		在 DEPRECATED 一词后，留下您的名字，邮箱地址以及括号补充。
		仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites），或是找个帮手。
		修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。

	8总结：
		1. 关于注释风格，很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段
		大段的注释时使用块注释;
		2. 文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;
		3. 注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;
		4. 对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难
		道是为了炫耀编程语言之外的你的母语或外语水平吗；
		5. 注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢
		这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;
		6. TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还
		有哪些活要干, 日志都省了	
	
9.格式
		
	9.1. 行长度
		Tip: 
			每一行代码字符数不超过 80
	
		结论:
			80 个字符是最大值.
			特例: • 如果一行注释包含了超过 80 字符的命令或 URL, 出于复制粘贴的方便允许该行超过 80 字符. • 包含长路径的 #include 语句可以超出 80 列. 但应该尽量避免. • 头文件保护 可以无视该原则.	
	9.2. 非ASCII字符
		Tip: 
			尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.
		
		即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符要少用. 特殊情况下可以适当包含
		此类字符. 如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不
		需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解
		和处理 UTF-8 编码.
		
		十六进制编码也可以, 能增强可读性的情况下尤其鼓励——比如 "\xEF\xBB\xBF" 在 Unicode 中是 零宽度无间断
		的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.
		(Yang.Y 注: "\xEF\xBB\xBF" 通常用作 UTF-8 with BOM 编码标记) 
		
		用 u8 前缀以把带 uXXXX 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上，因为如果编译器不把源代码识别成 UTF-8, 输出就会出错。
		
		别用 C++11 的 char16_t 和 char32_t, 它们和 UTF-8 文本没有关系，wchar_t 同理，除非您写的代码要调用
		Windows API, 后者有用到 wchar_t 扩展。		
	
	9.3 空格还是制表符
		Tip: 
			只使用空格, 每次缩进 2 个空格.
			我们使用空格缩进. 不要在代码中使用制符表. 你应该设置编辑器将制符表转为空格.
	
	9.4 函数声明与定义
		Tip: 
			返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。

		函数看上去像这样:
			ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
				DoSomething();
				...
			}
			如果同一行文本太多, 放不下所有参数:
			ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
														 Type par_name3) {
				DoSomething();
				...
			}
			甚至连第一个参数都放不下:
			ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
					Type par_name1, // 4 空格缩进
					Type par_name2,
					Type par_name3) {
				DoSomething(); // 2 空格缩进
				...
			}	
	
		注意以下几点:
			• 如果返回类型和函数名在一行放不下，分行。
			• 如果返回类型那个与函数声明或定义分行了，不要缩进。
			• 左圆括号总是和函数名在同一行;
			• 函数名和左圆括号间没有空格; 
			• 圆括号与参数间没有空格; 
			• 左大括号总在最后一个参数同一行的末尾处; 
			• 如果其它风格规则允许的话，右大括号 总是单独位于函数最后一行，或者与左大括号同一行。
			• 右大括号和左大括号间总是有一个空格; 
			• 函数声明和定义中的所有形参必须有命名且一致;
			• 所有形参应尽可能对齐; 
			• 缺省缩进为 2 个空格; 
			• 换行后的参数保持 4 个空格的缩进;	
	
		如果有些参数没有用到, 在函数定义处将参数名注释起来:
			// 接口中形参恒有命名。
			class Shape {
			public:
				virtual void Rotate(double radians) = 0; }
			// 声明中形参恒有命名。
			class Circle : public Shape {
			public:
				virtual void Rotate(double radians);
			}
			// 定义中注释掉无用变量。
			void Circle::Rotate(double /*radians*/) {}
		Warning:
			// 差 - 如果将来有人要实现，很难猜出变量是干什么用的。
			void Circle::Rotate(double) {}	
	
	9.5 lambda表达式	
		Tip: 
			其它函数怎么格式化形参和函数体，Lambda 表达式就怎么格式化；捕获列表同理。若用引用捕获，在变量名和 & 之间不留空格。
				int x = 0;
				auto add_to_x = [&x](int n) { x += n; };
		
		短 lambda 就写得和内联函数一样。
			std::set<int> blacklist = {7, 8, 9};
			std::vector<int> digits = {3, 9, 1, 8, 4, 7, 1};
			digits.erase(std::remove_if(digits.begin(), digits.end(), [&blacklist](int i) {
							return blacklist.find(i) != blacklist.end();
						}),
						digits.end());		
	
	9.6 函数调用
		Tip:
			要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的
			话，尽可能精简行数，比如把多个参数适当地放在同一行里。		
		
		函数调用遵循如下形式：
			bool retval = DoSomething(argument1, argument2, argument3);
		如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：
			bool retval = DoSomething(averyveryveryverylongargument1,
			argument2, argument3);
		参数也可以放在次行，缩进四格：
			if (...) {
				...
				...
				if (...) {
				DoSomething(
					argument1, argument2, // 4 空格缩进
					argument3, argument4);
			}		
		把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成
		行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：		
		
		如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给
		函数：
			int my_heuristic = scores[x] * y + bases[x];
			bool retval = DoSomething(my_heuristic, x, y, z);
		或者放着不管，补充上注释：
			bool retval = DoSomething(scores[x] * y + bases[x], // Score heuristic.
									  x, y, z);
		如果某参数独立成行，对可读性更有帮助的话，就这么办。
		此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：
		// 通过 3x3 矩阵转换 widget.
			my_widget.Transform(x1, x2, x3,
								y1, y2, y3,
								z1, z2, z3);		
		
	9.7 列表初始化
		Tip: 
			您平时怎么格式化函数调用，就怎么格式化5.20. 列表初始化。
		
		如果列表初始化伴随着名字，比如类型或变量名，您可以当名字是函数、{} 是函数调用的括号来格式化它。反之，就当它有个长度为零的名字。
			// 一行列表初始化示范。
			return {foo, bar};
			functioncall({foo, bar});
			pair<int, int> p{foo, bar};
			
			// 当不得不断行时。
			SomeFunction(
				{"assume a zero-length name before {"},
				some_other_function_parameter);
			SomeType variable{
				some, other, values,
				{"assume a zero-length name before {"},
			SomeOtherType{
				"Very long string requiring the surrounding breaks.",
				some, other values},
			SomeOtherType{"Slightly shorter string",
				me, other, values}};
			SomeType variable{
				"This is too long to fit all in one line"};
			MyType m = { // 注意了，您可以在 { 前断行。
			superlongvariablename1,
			superlongvariablename2,
			{short, interior, list},
			{interiorwrappinglist,
			interiorwrappinglist2}};		
		
	9.8 条件语句
		Tip: 
			倾向于不在圆括号内使用空格. 关键字 if 和 else 另起一行
		
		对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.
		最常见的是没有空格的格式. 哪种都可以, 但 保持一致性. 如果你是在修改一个文件, 参考当前已有格式. 如果是
		写新的代码, 参考目录下或项目中其它文件. 还在徘徊的话, 就不要加空格了.
			if (condition) { 圆括号里没空格紧邻。
				... // 2 空格缩进。
			} else { // else 与 if 的右括号同一行。
				...
			}
		如果你更喜欢在圆括号内部加空格:
			if ( condition ) { // 圆括号与空格紧邻 - 不常见
				... // 2 空格缩进。
			} else { // else 与 if 的右括号同一行。
				...
			}		
		
		注意所有情况下 if 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:
			Warning:
			if(condition) // 差 - IF 后面没空格。
			if (condition){ // 差 - { 前面没空格。
			if(condition){ // 变本加厉地差。
			if (condition) { // 可 - IF 和 { 都与空格紧邻。		
		
		如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用:
			if (x == kFoo) return new Foo();
			if (x == kBar) return new Bar();
		
		如果语句有 else 分支则不允许:
		Warning:
			// 不可以这样子 - 当有 ELSE 分支时 IF 块却只有一行
			if (x) DoThis();
			else DoThat();
		
		通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有
		一些项目要求 if 必须总是使用大括号:
			if (condition)
				DoSomething(); // 2 空格缩进。
			if (condition) {
				DoSomething(); // 2 空格缩进。
			}
		
		但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用:
			Warning:
				// 不可以这样子 - IF 有大括号 ELSE 却没有。
				if (condition) {
					foo;
				} else
					bar;
				// 不可以这样子 - ELSE 有大括号 IF 却没有。
				if (condition)
					foo;
				else {
					bar;
				}
				// 只要其中一个分支用了大括号，两个分支都要用上大括号。
				if (condition) {
					foo;
				} else {
					bar;
				}
		
	9.9 循环与开关选择语句
		Tip: 
			switch 语句可以使用大括号分段，以表明 cases 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 {} 或 continue
		
		switch 语句中的 case 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.
		如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配 (如果有输入值没有 case 去处理, 编
		译器将报警). 如果 default 应该永远执行不到, 简单的加条 assert:
			switch (var) {
				case 0: { // 2 空格缩进
					... // 4 空格缩进
					break; 
				}
				case 1: {
					...
					break; 
				}
				default: {
					assert(false);
				} 
			}		
		
		在单语句循环里，括号可用可不用：
			for (int i = 0; i < kSomeNumber; ++i)
				printf("I love you\n");
			for (int i = 0; i < kSomeNumber; ++i) {
				printf("I take it back\n");
			}
		空循环体应使用 {} 或 continue, 而不是一个简单的分号.
			while (condition) {
			// 反复循环直到条件失效。
			}
			for (int i = 0; i < kSomeNumber; ++i) {} // 可 - 空循环体。
			while (condition) continue; // 可 - contunue 表明没有逻辑。		
		
		Warning:
			while (condition); // 差 - 看起来仅仅只是 while/loop 的部分之一。
		
	9.10 指针和引用表达式
		Tip: 
			句点或箭头前后不要有空格. 指针/地址操作符 (*, &) 之后不能有空格.

		下面是指针和引用表达式的正确使用范例: 
			x = *p;
			p = &x;
			x = r.y;
			x = r->y;

		注意：
			• 在访问成员时, 句点或箭头前后没有空格. 
			• 指针操作符 * 或 & 后没有空格.
		在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:
			// 好样的，空格前置。
			char *c;
			const string &str;
			// 好样的，空格后置。
			char* c; // 但别忘了 "char* c, *d, *e, ...;"!
			const string& str;
		Warning:
			char * c; // 差 - * 两边都有空格
			const string & str; // 差 - & 两边都有空格	


	9.11 布尔表达式
		Tip: 
			如果一个布尔表达式超过标准行宽, 断行方式要统一一下.
			
		下例中, 逻辑与 (&&) 操作符总位于行尾:
			if (this_one_thing > this_other_thing &&
				a_third_thing == a_fourth_thing &&
				yet_another & last_one) {
				...
			}

		注意, 上例的逻辑与 (&&) 操作符均位于行尾. 这格式在 Google 里很常见，您要把所有操作符放在开头也可以。
		可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外直接用符号形式的操作符，比如 && 和 ~,
		不要用词语形式的 and 和 compl	

	9.12 函数返回值
		Tip: 
			return 表达式里时没必要都用圆括号。

		假如您写 x = epr 时本来就会加上括号，那 return expr; 也可如法炮制。
		函数返回时不要使用圆括号:
			return result; // 返回值很简单，没有圆括号。
			// 可以用圆括号把复杂表达式圈起来，改善可读性。
			return (some_long_condition &&
			another_condition);
		Warning:
			return (value); // 毕竟您从来不会写 var = (value);
			return(result); // return 可不是函数！

	9.13 变量及数组初始化
		Tip: 用 =, () 和 {} 均可.
		
		您可以用 =, () 和 {}, 以下都对：
			int x = 3;
			int x(3);
			int x{3};
			string name("Some Name");
			string name = "Some Name";
			string name{"Some Name"};		

		请务必小心列表初始化 {...} 用 std::initializer_list 构造函数初始化出的类型。非空列表初始化就会
		优先调用 std::initializer_list, 不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用
		std::initializer_list 构造函数，请改用括号。
			vector<int> v(100, 1); // A vector of 100 1s.
			vector<int> v{100, 1}; // A vector of 100, 1.
		此外，列表初始化不允许整型类型的四舍五入，这可以用来避免一些类型上的编程失误。
			int pi(3.14); // 可 -- pi == 3.
			int pi{3.14}; // Compile error: narrowing conversion

	
	9.14 预处理指令
		Tip: 
			预处理指令不要缩进, 从行首开始
		
		即使预处理指令位于缩进代码块中, 指令也应从行首开始.
			// 可 - directives at beginning of line
				if (lopsided_score) {
			#if DISASTER_PENDING // 正确 -- 行开头起。
				DropEverything();
			#endif
				BackToNormal();
			}
		Warning:
			// 差 - indented directives
				if (lopsided_score) {
					#if DISASTER_PENDING // 错了！ "#if" 应该放在行开头
					DropEverything();
					#endif // 错了！ "#endif" 不要缩进
					BackToNormal();
			}		
		
	9.15 类格式
		Tip: 
			访问控制块的声明依次序是 public:, protected:, private:, 每次缩进 1 个空格
		
		类声明 (对类注释不了解的话, 参考类注释) 的基本格式如下:
			class MyClass : public OtherClass {
			 public: // 注意有 1 空格缩进!
			  MyClass(); // 照常，2 空格缩进。
			  explicit MyClass(int var);
			  ~MyClass() {}
			 
			  void SomeFunction();
			  void SomeFunctionThatDoesNothing() {
			}		
		
			  void set_some_var(int var) { some_var_ = var; }
			  int some_var() const { return some_var_; }
			 private:
			  bool SomeInternalFunction();
			  
			  int some_var_;
			  int some_other_var_;
			  DISALLOW_COPY_AND_ASSIGN(MyClass);
			};		
		
		注意事项: 
			• 所有基类名应在 80 列限制下尽量与子类名放在同一行. 
			• 关键词 public:, protected:, private: 要缩进 1 个空格. 
			• 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空. 
			• 这些关键词后不要保留空行. 
			• public 放在最前面, 然后是 protected, 最后是 private. 
			• 关于声明顺序的规则请参考声明顺序 一节.		
					
	9.16 构造函数初始值列表
		Tip: 
			构造函数初始值列表放在同一行或按四格缩进并排几行.
		
		下面两种初始值列表方式都可以接受:
			// 当全放在一行合适时：
			MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {
		或
			// 如果要断成多行，缩进四格，冒号放在第一行初始化句：
			MyClass::MyClass(int var)
				: some_var_(var), // 4 空格缩进
				  some_other_var_(var + 1) { // 对准
			  ...
			  DoSomething();
			  ...
			}		
		
	9.17 命名空间格式化
		Tip: 
			命名空间内容不缩进
		
		命名空间 不要增加额外的缩进层次, 例如:
			namespace {
			void foo() { // 正确。命名空间内没有额外的缩进。
			...
			}
			} // namespace
		不要缩进命名空间:
			Warning:
			namespace {
				// 错，缩进多余了。
				void foo() {
				...
				} 
			} // namespace		
		
		声明嵌套命名空间时，每命名空间都独立成行。
			namespace foo {
			namespace bar {		
		
	9.18 水平留白
		Tip: 
			水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.
		
		常规:
			void f(bool b) { // 左大括号前恒有空格。
			...
			int i = 0; // 分号前不加空格。
			int x[] = { 0 }; // 大括号内部可与空格紧邻也不可，不过两边都要加上。
			int x[] = {0};
			// 继承与初始化列表中的冒号前后恒有空格。
			class Foo : public Bar {
			 public:
			  // 至于内联函数实现，在大括号内部加上空格并编写实现。
			  Foo(int b) : Bar(), baz_(b) {} // 大括号里面是空的话，不加空格。
			  void Reset() { baz_ = 0; } // 用括号把大括号与实现分开。
			  ...		
		
			添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完
			毕, 将多余的空格去掉; 或者在专门清理空格时去掉（确信没有其他人在处理). (Yang.Y 注: 现在大部分代
			码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)		
		
		循环和条件语句:
			if (b) { // if 条件语句和循环语句关键字后均有空格。
			} else { // else 前后有空格。
			}
			while (test) {} // 圆括号内部不紧邻空格。
			switch (i) {
			for (int i = 0; i < 5; ++i) {
			switch ( i ) { // 循环和条件语句的圆括号里可以与空格紧邻。
			if ( test ) { // 圆括号，但这很少见。总之要一致。
			for ( int i = 0; i < 5; ++i ) {
			for ( ; i < 5 ; ++i) { // 循环里内 ; 后恒有空格，； 前可以加个空格。
			switch (i) {
				case 1: // switch case 的冒号前无空格。
				...
				case 2: break; // 如果冒号有代码，加个空格。		
	
		操作符:
			// 赋值操作系统前后恒有空格。
			x = 0;
			
			// 其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。
			// 圆括号内部不紧邻空格。
			v = w * x + y / z;
			v = w*x + y/z;
			v = w * (x + z);
			
			// 在参数和一元操作符之间不加空格。
			x = -5; ++x;
			if (x && !y)
			...		
		
		模板和转换:
			// 尖叫括号 (< and >) 不与空格紧邻，< 前没有空格，>( 之间也没有。
			vector<string> x;
			y = static_cast<char*>(x);
			
			// 在类型与指针操作符之间留空格也可以，但要保持一致。
			vector<char *> x;
			set<list<string>> x; 		// 在 C++11 代码里可以这样用了。
			set<list<string> > x; 		// C++03 中要在 > > 里留个空格。
			
			// 您或许可以在 < < 里加上一对对称的空格。
			set< list<string> > x;		
		
	9.19 垂直留白
		Tip: 
			垂直留白越少越好
		
			这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.
			基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码
			块同样难看, 取决于你的判断. 但通常是垂直留白越少越好.
		空行心得如下：
			• 函数体内开头或结尾的空行可读性微乎其微。
			• 在多重 if-else 块里加空行或许有点可读性。		
		
	9总结1：
		1. 对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;
		2. 行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;
		3. 尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽
		字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;
		4. UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;
		5. 函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;
		6. 除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右
		大括号独立成行;
		7. ./-> 操作符前后不留空格, */& 不要前后都留, 一个就可, 靠左靠右依各人喜好;
		8. 预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;
		9. 初始化用 = 还是 () 依个人喜好, 统一就好;
		10. return 不要加 ();
		11. 水平/垂直留白不要滥用, 怎么易读怎么来.
		12. 关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (.cc 文件的函数实现处, 左大括号位于行首), 我的理解是
		代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服;
		Windows 风格将左大括号置于行首的优点是匹配情况一目了然.
	
	9总结2：
		1. 80 行限制事实上有助于避免代码可读性失控，比如超多重嵌套块，超多重函数调用等等。
		2. Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码，不像奇葩的 Windows.
		3. Google 强调有一对 if-else 时，不论有没有嵌套，都要有大括号。Apple 正好 有栽过跟头 .
		4. 其实我主张指针／地址操作符与变量名紧邻，int* a, b vs int *a, b, 新手会误以为前者的 b 是 int * 变量，
		但后者就不一样了，高下立判。
		5. 在这风格指南里我才刚知道 C++ 原来还有所谓的 Alternative operator representations, 大概没人用吧。
		6. 注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事，我就差点
		混淆了它们的翻译。
		7. 事实上，如果您熟悉英语本身的书写规则，就会发现该风格指南在格式上的规定与英语语法相当一脉相承。
		比如普通标点符号和单词后面还有文本的话，总会留一个空格；特殊符号与单词之间就不用留了，比如 if
		(true) 中的圆括号与 true.
		8. 本风格指南没有明确规定 void 函数里要不要用 return 语句，不过就 Google 开源项目 leveldb 并没有写；此外
		从 Is a blank return statement at the end of a function whos return type is void necessary? 来看，return; 比
		return ; 更约定俗成（事实上 cpplint 会对后者报错，指出分号前有多余的空格），且可用来提前跳出函数栈。		
		
		
10. 规则特例
	
	10.1 现有不合格的代码
		Tip: 
			对于现有不符合既定编程风格的代码可以网开一面
		
		当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心可以与代码原作者或现在的负责人员商讨, 记住, 一致性 包括原有的一致性.		
		
	10.2 windows代码
		Tip: 
			Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.
		
	如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南: 
		• 不要使用匈牙利命名法 (比如把整型变量命名成 iNum). 使用 Google 命名约定, 包括对源文件使用 .cc 扩展名. 
		• Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 DWORD, HANDLE 等等. 在调用
		  Windows API 时这是完全可以接受甚至鼓励的. 但还是尽量使用原有的 C++ 类型, 例如, 使用 const TCHAR *
		  而不是 LPCTSTR. 
		• 使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有 warnings 当作 errors 处理. 
		• 不要使用 #pragma once; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录
		  (Yang.Y 注: 如 #ifndef SRC_DIR_BAR_H_, 参考 #define 保护一节).
		• 除非万不得已, 不要使用任何非标准的扩展, 如 #pragma 和 __declspec. 允许使用 __declspec(dllimport) 和
		  __declspec(dllexport); 但你必须通过宏来使用, 比如 DLLIMPORT 和 DLLEXPORT, 这样其他人在分享使用这些
		  代码时很容易就去掉这些扩展. 在 Windows 上, 只有很少的一些情况下, 我们可以偶尔违反规则: 
		• 通常我们禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或
		  ATL/WTL 类/接口, 你可能不得不使用多重实现继承.
		• 虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用
		  ATL 时, 应定义 _ATL_NO_EXCEPTIONS 以禁用异常. 你要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 启
		  用编译器异常也可以. (注意这只是为了编译 STL, 自己代码里仍然不要含异常处理.)
		• 通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 StdAfx.h 或 precompile.h 的文件. 为
		  了使代码方便与其他项目共享, 避免显式包含此文件 (precompile.cc), 使用 /FI 编译器选项以自动包含. 
		• 资源头文件通常命名为 resource.h, 且只包含宏的, 不需要遵守本风格指南.		
			
		
11.the end
	Tip: 
		运用常识和判断力, 并 保持一致.
		
		编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 if 语句使用空格, 那么你也要使
	用. 如果其中的注释用星号 (*) 围成一个盒子状, 你同样要这么做.
		风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展
	示了全局的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文
	件本身的整体美观, 也影响阅读, 所以要尽量避免	
		
		
		
		
		
		
		
		
		
		
		
		