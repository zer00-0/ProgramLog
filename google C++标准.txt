1、头文件
	1.1. Self-contained 头文件
		Tip: 
			头文件应该能够自给自足（self-contained, 也就是可以作为第一个头文件被引入），以 .h 		  结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 .inc 结尾。不允许分离出 -inl.h 头文件的做法
		
		即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上
		是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 .inc 文件扩展名。
		
		如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。
		有个例外：
			如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定
			义在实例化该模板的 .cc 文件里。
			
	1.2. #define 保护
		Tip: 
			所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: <PROJECT>_<PATH>_<FILE>_H_
			
		为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/
		baz.h 可按如下方式保护:
			#ifndef FOO_BAR_BAZ_H_
			#define FOO_BAR_BAZ_H_
			…
			#endif // FOO_BAR_BAZ_H_		
					
	1.3. 前置声明（详见https://www.zhihu.com/question/63201378）
		Tip: 
			尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
			
		定义：
			所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.	
			
		优点：
			• 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。
			• 前置声明能够节省不必要的重新编译的时间。#include 使代码因为头文件中无关的改动而被重新编译多次。
		缺点：
			• 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
			• 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API.
			  例如扩大形参类型，加个自带默认参数的模板形参等等。
			• 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。
			• 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替includes   甚至都会暗暗地改变代码的含义：	
			
		如果 #include 被 B 和 D 的前置声明替代，test() 就会调用 f(void*) . * 前置声明了不少来自头文件的
		symbol 时，就会比单单一行的 include 冗长。* 仅仅为了能前置声明而重构代码（比如用指针成员代替
		对象成员）会使代码变得更慢更复杂.	
			// b.h:
			struct B {};
			struct D : B {};

			// good_user.cc:
			#include "b.h"
			void f(B*);
			void f(void*);
			void test(D* x) { f(x); }  // calls f(B*)
		例如，如果一个类的实现者需要把这个类改个名字/换个命名空间，出于兼容性他原本可以在原命名空间里/用原名通过using来起一个别名指向新类。然而别名不能被前向声明。内网有一份代码改动一下子试图修改总计265个头文件，就是实现者为了要改这个类的名字而不得不去改所有的调用处。想一想，如果这265个文件分属于50个不同的团队，你得拿到50个人的同意才能提交这份改动，想不想打人？			
			
		结论：
			• 尽量避免前置声明那些定义在其他项目中的实体. 
			• 函数：总是使用 #include. 
			• 类模板：优先使用 #include	
			
	1.4. 内联函数
		Tip: 
			只有当函数只有 10 行甚至更少时才将其定义为内联函数.
			
		结论:
			•一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起
				来要更长, 因为有隐含的成员和基类析构函数被调用!
			•另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下,
				这些循环或 switch 语句从不被执行).
			•有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联
			
	1.5. #include的路径及顺序
		Tip: 
			使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h,项目内的 .h.
		
		项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 
			例如, google-awesome-project/src/base/logging.h 应该按如下方式包含:
			 
					#include "base/logging.h"	
			
		又如, dir/foo.cc 的主要作用是实现或测试 dir2/foo2.h 的功能, foo.cc 中包含头文件的次序如下:
		
			1. dir2/foo2.h (优先位置, 详情如下)
			2. C 系统文件
			3. C++ 系统文件
			4. 其他库的 .h 文件
			5. 本项目内 .h 文件
			
		这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时，dir/foo.cc 或 dir/foo_test.cc 的构建会立
		刻中止。因此这一条规则保证维护这些文件的人首先看到构建中止的消息而不是维护其他包的人。
		dir/foo.cc 和 dir2/foo2.h 通常位于同一目录下 (如 base/basictypes_unittest.cc 和 base/basictypes.h),
		但也可以放在不同目录下.			
		
	    按字母顺序对头文件包含进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们		
	
	小结1：	
		1. 避免多重包含是学编程时最基本的要求;
		2. 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;
		3. 内联函数的合理使用可提高代码执行效率;
		4. -inl.h 可提高代码可读性 (一般用不到吧:D);
		5. 标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放
		在一起);
		6. 包含文件的名称使用 . 和 .. 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的
		次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处:D) 的地方编
		译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证
		内部错误的及时发现了.		
		
	小结2：
		1. 原来还真有项目用 #includes 来插入文本，且其文件扩展名 .inc 看上去也很科学。
		2. Google 已经不再提倡 -inl.h 用法。
		3. 注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但
		不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建
		其类的任何对象，也不能声明成类内部的数据成员。
		4. 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的
		.cc 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。
		5. 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯		
		
2、作用域
	2.1.命名空间
		Tip: 
			鼓励在 .cc 文件内使用匿名名字空间. 使用具名的名字空间时, 其名称可基于项目名或相对路径. 禁止使用using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。
		
		2.1.1. 匿名命名空间
			• 在 .cc 文件中, 允许甚至鼓励使用匿名名字空间, 以避免运行时的命名冲突:
	
				namespace { // .cc 文件中
				// 名字空间的内容无需缩进
				enum { kUNUSED, kEOF, kERROR }; // 经常使用的符号
				bool AtEof() { return pos_ == kEOF; } // 使用本名字空间内的符号 EOF
				} // namespace	
				
				然而, 与特定类关联的文件作用域声明在该类中被声明为类型, 静态数据成员或静态成员函数, 而不是匿名名字空
				间的成员. 如上例所示, 匿名空间结束时用注释 // namespace 标识. 
			• 不要在 .h 文件中使用匿名名字空间.		
			
		2.1.2.具名命名空间
			具名的名字空间使用方式如下: 
			• 用名字空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间			
	
				// 在.h 文件中声明
				namespace mynamespace {
				// 所有声明都置于命名空间中
				// 注意不要使用缩进
				class MyClass {
				public:
				…
				void Foo();
				};
				} // namespace mynamespace
				
				// 在.cc 文件中定义
				namespace mynamespace {
				// 函数定义都置于命名空间中
				void MyClass::Foo() {
				… }
				} // namespace mynamespace	
		
			• 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体会导致不确定的问
				题, 比如不可移植. 声明标准库下的实体, 需要包含对应的头文件. 
				
			• 最好不要使用 using 指示，以保证命名空间下的所有名称都可以正常使用.
				// 禁止 —— 污染命名空间
					using namespace foo;
					
			• 在 .cc 文件, .h 文件的函数, 方法或类中, 可以使用 using 声明。
				// 允许: .cc 文件中
				// .h 文件的话, 必须在函数, 方法或类的内部使用
					using ::foo::bar;
					
			• 在 .cc 文件, .h 文件的函数, 方法或类中, 允许使用命名空间别名.	
				// 允许: .cc 文件中
				// .h 文件的话, 必须在函数, 方法或类的内部使用
					namespace fbz = ::foo::bar::baz;
					
				// 在 .h 文件里
					namespace librarian {
					//以下别名在所有包含了该头文件的文件中生效。
					namespace pd_s = ::pipeline_diagnostics::sidetable;
					inline void my_inline_function() {
						// namespace alias local to a function (or method).
						namespace fbz = ::foo::bar::baz;
						...
					}} // namespace librarian	
	
				注意在.h 文件的别名对包含了该头文件的所有人可见，所以在公共头文件（在项目外可用）以及它们
				递归包含的其它头文件里，不要用别名。毕竟原则上公共 API 要尽可能地精简。
			• 禁止用内联命名空间
	
	2.2.嵌套类
		Tip: 
			当公有嵌套类作为接口的一部分时, 虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于2.1. 名字空间 内是更好的选择.
		结论:
			不要将嵌套类定义成公有, 除非它们是接口的一部分, 比如, 嵌套类含有某些方法的一组选项.
	
	2.3.非成员函数、静态成员函数和全局函数
		Tip: 
			使用静态成员函数或命名空间内的非成员函数, 尽量不要用未封装的全局函数
	
		结论:
		•有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非
		 成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享
		 任何静态数据的静态成员函数而创建类, 不如使用2.1. 命名空间。
		
		•定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员
		 函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.
		
		•如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 namespaces‘或 ‘‘static‘ 链接关键字
		 (如 static int Foo() {...}) 限定其作用域.	
	
	2.4.局部变量
		Tip: 
			将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
			
			C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使
			得代码浏览者更容易定位变量声明的位置,了解变量的类型和初始值.特别是，应使用初始化的方式替代声明再赋值	
				
			Warning: 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数.
		
		
	2.5.静态与全局变量
		Tip: 
			禁止使用 class 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。		
	
		•静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型(POD : 
		 Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。		
		
		•静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是不确定的，甚至随着构建变化而变化，导致难以发现的 bug.
		 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数不涉及
		（比如 getenv() 或 getpid()）不涉及任何全局变量。（函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确
		 定义的，而且只会在指令执行到它的声明那里才会发生。）
		 
		•同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 main() 返回还是对 exit() 
		 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。
		
		•改善以上析构问题的办法之一是用 quick_exit() 来代替 exit() 并中断程序。它们的不同之处是前者不会执行
		 任何析构，也不会执行 atexit() 所绑定的任何 handlers. 如果您想在执行 quick_exit() 来中断时执行某 handler
		 （比如刷新 log），您可以把它绑定到 _at_quick_exit(). 如果您想在 exit() 和 quick_exit() 都用上该 handler, 都
		 绑定上去。
		
		综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 constchar [])。
		
		如果您确实需要一个 class 类型的静态或全局变量，可以考虑在 main() 函数或 pthread_once() 内初始化一个
		指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。
		
		
		小结1：
		1. cc 中的匿名名字空间可避免命名冲突, 限定作用域, 避免直接使用 using 关键字污染命名空间;
		2. 嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 public;
		3. 尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;
		4. 多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug.
		5. 作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.
		
		小结2：
		1. 注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。
		2. 匿名名字空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。
		3. 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体
		系结构重要的概念「局部性（locality）」。
		4. 注意别在循环犯大量构造和析构的低级错误。		
	
3.类
	3.1. 构造函数的职责
		Tip: 
			不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化)
	
		结论:
			构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化,
			考虑使用明确的 Init() 方法或使用工厂模式
		
	3.2.初始化
		Tip: 
			如果类中定义了成员变量, 则必须在类中为每个类提供初始化函数或定义一个构造函数. 若未声明构造函数, 
			则编译器会生成一个默认的构造函数, 这有可能导致某些成员未被初始化或被初始化为不恰当的值.
		
		结论:
			•简单的初始化用类成员初始化完成, 尤其是当一个成员变量要在多个构造函数里用相同的方式初始化的时候.
			•如果你的类中有成员变量没有在类里面进行初始化, 而且没有提供其它构造函数, 你必须定义一个 (不带参数的) 默认构造函数. 把对象的内部状态初始化成一致/ 有效的值无疑是更合理的方式.
				这么做的原因是: 如果你没有提供其它构造函数, 又没有定义默认构造函数, 编译器将为你自动
				生成一个. 编译器生成的构造函数并不会对对象进行合理的初始化.
				如果你定义的类继承现有类, 而你又没有增加新的成员变量, 则不需要为新类定义默认构造函数	
		
	3.3.显式构造函数
		Tip: 
			对单个参数的构造函数使用 C++ 关键字 explicit.
		
		通常, 如果构造函数只有一个参数, 可看成是一种隐式转换. 打个比方, 如果你定义了 Foo::Foo(string
		name), 接着把一个字符串传给一个以 Foo 对象为参数的函数, 构造函数 Foo::Foo(string name) 将被
		调用, 并将该字符串转换为一个 Foo 的临时对象传给调用函数（如父类转换成子类类型）
		除单参数构造函数外, 这一规则也适用于除第一个参数以外的其他参数都具有默认参数的构造函数
		
		
		结论:
			所有单参数构造函数都必须是显式的. 在类定义中, 将关键字 explicit 加到单参数构造函数前: explicit
			Foo(string name);
	
	3.4. 可拷贝类型与可移动类型
		Tip: 
			如果你的类型需要, 就让它们支持拷贝/ 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.
		
		定义：
			可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 	
			同时不改变源对象的值，（ string 类型就是一个可拷贝类型的例子.）
			
			可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的)（std::unique_ptr<int> 就是一个可移动但不可复制的对象的例子）
			移动操作允许隐式且高效地将源数据转移出右值对象
		
		结论:
			如果需要就让你的类型可拷贝/ 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一
			眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值
			操作的定义. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造
			函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类
			型设置为只可移动并定义移动的两个操作.
			
				建议通过 = default 定义拷贝和移动操作. 定义非默认的移动操作目前需要异常. 时刻记得检
				测默认操作的正确性. 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操
				作或者拷贝/ 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复
				制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类
				实现.
				如果你的类不需要拷贝/ 移动操作, 请显式地通过 = delete 或其他手段禁用之		
		
		
	3.5.委派与继承构造函数
		Tip: 
			在能够减少重复代码的情况下使用委派和继承构造函数
		
		定义:
			委派和继承构造函数是由 C++11 引进为了减少构造函数重复代码而开发的两种不同的特性. 通过特殊的
			初始化列表语法, 委派构造函数允许类的一个构造函数调用其他的构造函数. 
			例如: 
					X::X(const string& name) : name_(name) {
					...
					}X::X() : X("") { }		
		
		结论:
			只在能够减少冗余代码, 提高可读性的前提下使用委派和继承构造函数. 如果派生类有新的成员变量, 那么
			使用继承构造函数时要小心. 如果在派生类中对成员变量使用了类内部初始化的话, 继承构造函数还是适
			用的.		
		
		
	3.6.结构体与类
		Tip: 
			当且仅当只有数据时使用 struct, 其它一概使用 class.
		
		为了和 STL 保持一致, 对于仿函数和 trait 特性可以不用 class 而是使用 struct.
		注意: 类和结构体的成员变量使用不同的命名规则.
		
	3.7.继承
		Tip: 
			使用组合 (composition, YuleFox 注: 这一点也是 GoF 在 <<Design Patterns>> 里反复强调的) 
			常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承
		
		结论:
			所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.
			不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a”
			情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.
			必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意数据成员在
			任何情况下都必须是私有的.
			当重载一个虚函数, 在衍生类中把它明确的声明为 virtual. 理论依据: 如果省略 virtual 关键字, 代码阅
			读者不得不检查所有父类, 以判断该函数是否是虚函数.		
		
	3.8.多重继承
		Tip: 
			真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的纯接口类
		
		结论:
			只有当所有父类除第一个外都是纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以
			Interface 为后缀.		
	
	3.9.接口（interface具体实现https://www.coder.work/article/574550）
		Tip: 
			接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制)

		定义:
			当一个类满足以下要求时, 称之为纯接口:
				• 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).
				• 没有非静态数据成员. 
				• 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected. 
				• 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.
				
			接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明
			虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数)		
		
	3.10.运算符重载
		Tip:
			除少数特定环境外，不要重载运算符

		结论：
			一般不要重载运算符. 尤其是赋值操作 (operator=) 比较诡异, 应避免重载. 如果需要的话, 可以定义类似
			Equals(), CopyFrom() 等函数.
			然而, 极少数情况下可能需要重载运算符以便与模板或 “标准” C++ 类互操作 (如 operator<<(ostream&,
			const T&)). 只有被证明是完全合理的才能重载, 但你还是要尽可能避免这样做. 尤其是不要仅仅为了在
			STL 容器中用作键值就重载 operator== 或 operator<; 相反, 你应该在声明容器的时候, 创建相等判断和
			大小比较的仿函数类型
	
	3.11.存取控制
		Tip:
		将 所有 数据成员声明为 private, 并根据需要提供相应的存取函数. 例如, 某个名为 foo_ 的变量, 其取值函数
		是 foo(). 还可能需要一个赋值函数 set_foo().
			特例是, 静态常量数据成员 (一般写做 kFoo) 不需要是私有成员.
			一般在头文件中把存取函数定义成内联函数.		
		
	3.12.声明顺序
		Tip: 
			在类中使用特定的声明顺序: public: 在 private: 之前, 成员函数在数据成员 (变量) 前;

		类的访问控制区段的声明顺序依次为: public:, protected:, private:. 如果某区段没内容, 可以不声明.
		每个区段内的声明通常按以下顺序: 
			• typedefs 和枚举
			• 常量
			• 构造函数
			• 析构函数
			• 成员函数, 含静态成员函数
			• 数据成员, 含静态数据成员
			
		友元声明应该放在 private 区段. 如果用宏 DISALLOW_COPY_AND_ASSIGN 禁用拷贝和赋值, 应当将其置
		于 private 区段的末尾, 也即整个类声明的末尾	
		
		.cc 文件中函数的定义应尽可能和声明顺序一致.
		
		不要在类定义中内联大型函数. 通常, 只有那些没有特别意义或性能要求高, 并且是比较短小的函数才能被定义为
		内联函数.

		
		
		
		3总结：
			1. 不在构造函数中做太多逻辑相关的初始化;
			2. 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自
			行提供默认构造函数;
			3. 为避免隐式转换, 需将单参数构造函数声明为 explicit;
			4. 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现;
			5. 仅在作为数据集合时使用 struct;
			6. 组合 > 实现继承 > 接口继承 > 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这
			样做;
			7. 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;
			8. 接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非
			静态数据成员, 不提供构造函数, 提供的话，声明为 protected;
			9. 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;
			10. 存取函数一般内联在头文件中;
			11. 声明次序: public -> protected -> private;
			12. 函数体尽量短小, 紧凑, 功能单一;		
		
4.函数
	4.1.参数顺序
		Tip：
			函数的参数顺序为: 输入参数在先, 后跟输出参数.
		
		C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前		
		
	4.2.编写简短函数
		Tip: 倾向编写简短, 凝练的函数（太长考虑分割函数）
		
		我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影
		响程序结构的前提下对其进行分割.
		
		即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题. 甚至导致难以发现的 bug. 使函数
		尽量简短, 便于他人阅读和修改代码.
		
		在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用/ 调试困难, 或者你
		需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数	
		
	4.3.引用参数
		Tip：
			所有按引用传递的参数必须加上 const
			
		结论：
			函数参数列表中, 所有引用参数都必须是 const:
				void Foo(const string &in, string *out);
				
			事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap().

			有时候, 在输入形参中用 const T* 指针比 const T& 更明智. 比如:
				可能会传递空指针.
				函数要把指针或对地址的引用赋值给输入形参.
			
			总而言之, 大多时候输入形参往往是 const T&. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑.		
		
	4.4.函数重载
		Tip：
			若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数
		
		定义：
			你可以编写一个参数类型为 const string& 的函数, 然后用另一个参数类型为 const char* 的函数对其进行重载:
				class MyClass {
					public:
					void Analyze(const string &text);
					void Analyze(const char *text, size_t textlen);
				};
		结论：
			如果打算重载一个函数, 可以试试在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append(). 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.		
		
	4.5.缺省参数
		Tip：
			只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.
		
		总结：
			对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 void f(int n = counter++); 这样的代码.)

			在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.		
		
	4.6. 函数返回类型后置语法
		Tip:
			只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.（使用auto）
		
		C++11 引入了这一新的形式. 现在可以在函数名前使用 auto 关键字, 在参数列表之后后置返回类型. 例如:
				auto foo(int x) -> int;
			与
				int foo(int x);
		后置返回类型为函数作用域. 对于像 int 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.
	
		结论：
			在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码.		
		
5.来自google的奇技
	
	5.1.所有权与智能指针
		Tip: 
			动态分配出的对象最好有单一且固定的所有主（onwer）, 且通过智能指针传递所有权（ownership）.
		
		定义：
			所有权是一种登记／管理动态内存和其它资源的技术。动态分配出的对象的所有主是一个对象或函数，后
			者负责确保当前者无用时就自动销毁前者。所有权有时可以共享，那么就由最后一个所有主来负责销毁
			它。甚至也可以不用共享，在代码中直接把所有权传递给其它对象。
			其实您可以把智能指针当成一个重载了 * 和 -> 的「对象」来看。智能指针类型被用来自动化所有权的登
			记工作，来确保执行销毁义务到位。std::unique_ptr 是 C++11 新推出的一种智能指针类型，用来表示
			动态分配出的对象的「独一无二」所有权；当 std::unique_ptr 离开作用域，对象就会被销毁。不能复
			制 std::unique_ptr, 但可以把它移动（move）给新所有主。std::shared_ptr 同样表示动态分配对象的
			所有权，但可以被共享，也可以被复制；对象的所有权由所有复制者共同拥有，最后一个复制者被销毁
			时，对象也会随着被销毁。		
		
		决定：
			如果必须使用动态分配，倾向于保持分配者的所有权。如果其他地方要使用这个对象，最好传递它的拷
			贝，或者传递一个不用改变所有权的指针或引用。倾向于使用 std::unique_ptr 来明确所有权传递，例
			如：
				std::unique_ptr<Foo> FooFactory();
				void FooConsumer(std::unique_ptr<Foo> ptr);
			
			避 免 使 用 共 享 所 有 权。 如 果 对 性 能 要 求 很 高， 并 且 操 作 的 对 象 是 不 可 变 的 （比 如 说
			std::shared_ptr<const Foo> ），这时可以用共享所有权来避免昂贵的拷贝操作。如果确实要使用
			共享所有权，倾向于使用 std::shared_ptr 。
			
			不要在新代码中使用 scoped_ptr `` ，除非你必须兼容老版本的 C++。总是用 ``std::unique_ptr 代 替 std::auto_ptr 。		
		
		
	5.2.cpplint（https://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py）
		Tip: 
			使用 cpplint.py 检查风格错误.
		
		cpplint.py 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍
		然是一个非常有用的工具. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错。
		某些项目会指导你如何使用他们的项目工具运行 cpplint.py. 如果你参与的项目没有提供, 你可以单独下载
		cpplint.py.
		
		总结：
			1. 把智能指针当成对象来看待的话，就很好领会它与所指对象之间的关系了。
			2. 原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊。
			3. scoped_ptr 和 auto_ptr 已过时。现在是 shared_ptr 和 uniqued_ptr 的天下了。
			4. 按本文来说，似乎除了智能指针，还有其它所有权机制，值得留意。
			5. Arch Linux 用户注意了，AUR 有对 cpplint 打包。		
	
6.C++其他特性
	
	6.1.引用参数
		Tip: 所有按引用传递的参数必须加上 const.（同4.3）
		
	6.2.右值引用（https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8）
		Tip: 
			只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 std::forward
		
		定义:
			左值为确定的有内存分配的值，右值为非左值（大部分情况为没有内存分配）
			右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, void
			f(string&& s); 声明了一个其参数是一个字符串的右值引用的函数
		
		结论:
			只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数. 你可能会使
			用 std::move 来表示将值从一个对象移动而不是复制到另一个对象.
		
	6.3.变长数组和alloc()
		Tip：我们不允许使用变长数组和 alloc().
			
			alloc()根据数据大小动态分配堆栈内存，容易内存越界
		结论:
			改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr<T[]>.

	6.4.右元
		Tip：我们允许合理的使用友元类及友元函数.
		
		通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 FooBuilder 声明为 Foo 的友元, 以便 FooBuilder 正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.

		友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 public, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.		

	6.5.异常
		Tip：我们不使用 C++ 异常.
		
		结论:

			从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.

			鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.		

	6.6.运行时类型识别
		Tip：我们禁止使用 RTTI.
		
		结论:
			RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其
			他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类
			型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:
			
				虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.
				
				如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在
				对象之外进行类型判断.
			
			如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在
			这种情况下, 使用 dynamic_cast 也是一种替代方案		

			基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:
				if (typeid(*data) == typeid(D1)) {
				...
				} else if (typeid(*data) == typeid(D2)) {
				...
				} else if (typeid(*data) == typeid(D3)) {
				...
				
			一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到
			并修改所有受影响的代码块.
			不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继
			承体系. 而且, 这些方案会掩盖你的真实意图.
	6.7.类型转换
		Tip: 
			使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式
		
		结论:
			不要使用 C 风格类型转换. 而应该使用 C++ 风格. 
				• 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.
				• 用 const_cast 去掉 const 限定符. 
				• 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 
				  仅在你对所做一切了然于心时使用.
			至于 dynamic_cast 参见6.6. 运行时类型识别.
		
	6.8.流
		Tip: 只在记录日志时使用流.
		
		定义:
			流用来替代 printf() 和 scanf()
		结论:
			不要使用流, 除非是日志接口需要. 使用 printf 之类的代替.
			使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流
			
		流与printf + read/write，每一种方式都是各有利弊, “没有最好, 只有更适合”. 
		简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 printf + read/write
		
	6.9.前置自增与自减
		Tip: 
			对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, （--i）自减运算符
		
		结论:
			对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).
		
	6.10.const用法
		Tip: 
			我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。
		
		结论:
			const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强
			烈建议在任何可能的情况下使用 const: 
				• 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const. 
				• 尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const
				  函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const. 
				• 如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.
			
			然而, 也不要发了疯似的使用 const. 像 const int * const * const x; 就有些过了, 虽然它非常精确
			的描述了常量 x. 关注真正有帮助意义的信息: 前面的例子写成 const int** x 就够了.
			关键字 mutable 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.
			const 的位置:
			有人喜欢 int const *foo 形式, 不喜欢 const int* foo, 他们认为前者更一致因此可读性也更好: 遵循
			了 const 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消
			大部分你原本想保持的一致性. 将 const 放在前面才更易读, 因为在自然语言中形容词 (const) 是在名词
			(int) 之前.
			这是说, 我们提倡但不强制 const 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把
			const 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)		
	
	6.11.constexpr用法（表示该变量在编译器可以计算出来，const未区分）
		Tip: 
			在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。const只限制只读（避免双重语义）
			（http://c.biancheng.net/view/7807.html）
		定义:
			变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函
			数也可以被声明成 constexpr, 以用来定义 constexpr 变量。	
		
		结论: 
			靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真常量以
			及支持常量的函数。避免复杂的函数定义，以使其能够与 constexpr 一起使用。千万别痴心妄想地想靠 constexpr 来强制代码「内联」。		
	
	6.12.整型
		Tip: 
			C++ 内建整型中, 仅使用 int. 如果程序中需要不同大小的变量, 可以使用 <stdint.h> 中长度精确的整型, 如
			int16_t. 如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 int64_t. 此外要留意，哪怕您
			的值并不会超出int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。		
		
		定义:
			C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64
			位.
		
		结论:
			<stdint.h> 定义了 int16_t, uint32_t, int64_t 等整型, 在需要确保整型大小时可以使用它们代替
			short, unsigned long long 等. 在 C 整型中, 只使用 int. 在合适的情况下, 推荐使用标准类型如 size_t
			和 ptrdiff_t.
			
			如果已知整数不会太大, 我们常常会使用 int, 如循环计数. 在类似的情况下使用原生类型 int. 你可以认
			为 int 至少为 32 位, 但不要认为它会多于 32 位. 如果需要 64 位整型, 用 int64_t 或 uint64_t.
			对于大整数, 使用 int64_t.

			不要使用 uint32_t 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补
			码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.
			如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型
			越大越好。
			
			小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 int 与 unsigned int 运算时，
			前者被提升为 unsigned int 而有可能溢出），总有意想不到的后果。
			关于无符号整数:		
		
	6.13. 64位下的可移植性
		Tip: 
			代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:
			
		类型						不要使用		 		使用 					备注
		void * (或其他指针类型)        %lx 			    	%p
		int64_t 					%qd,%lld 				%"PRId64"
		uint64_t 				%qu, %llu, %llx 		%"PRIu64", %"PRIx64"
		size_t							%u 	   	 		%"PRIuS", %"PRIxS" 		 C99 规定 %zu
		ptrdiff_t 						%d 				%"PRIdS"				 C99 规定 %zd		
		
		• 记住 sizeof(void *) != sizeof(int). 如果需要一个指针大小的整数要用 intptr_t. 
		• 你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序
		  保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 int64_t/uint64_t 成员的类/结构体, 缺省都以 8 字节
		  在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多
		  数编译器都允许调整结构体对齐. gcc 中可使用 __attribute__((packed)). MSVC 则提供了 #pragma pack()
		  和 __declspec(align()) (YuleFox 注, 解决方案的项目属性里也可以直接设置).
		• 创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:
			  int64_t my_value = 0×123456789LL;
			  uint64_t my_mask = 3ULL << 48;
		• 如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 #ifdef _LP64 指令来切分 32/64 位代码. (尽量不
		  要这么做, 如果非用不可, 尽量使修改局部化)		
	6.14. 预处理宏
		Tip: 
			使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之
		
		下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:
			• 不要在 .h 文件中定义宏. 
			• 在马上要使用时才进行 #define, 使用后要立即 #undef. 
			• 不要只是对已经存在的宏使用 #undef，选择一个不会冲突的名称；
			• 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为. 
			• 不要用 ## 处理函数，类和变量的名字。		
		
	6.15 0 ，nullptr和NULL
		Tip: 
			• 整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 '\0'.整数用 0, 实数用 0.0,     
			  这一点是毫无争议的.
			• 对于指针 (地址值), 到底是用 0, NULL 还是 nullptr. C++11 项目用 nullptr; C++03 项目则用 NULL, 毕竟它
			  看起来像指针。实际上，一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL)
			  就和 sizeof(0) 不一样。
			• 字符 (串) 用 '\0', 不仅类型正确而且可读性好		
		
	6.16. sizeof
		Tip: 
			尽可能用 sizeof(varname) 代替 sizeof(type).
				int a； sizeof（a） 与   sizeof（int）
			使用 sizeof(varname) 是因为当代码中变量类型改变时会自动更新. 您或许会用 sizeof(type) 处理不涉及任
			何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。
		
	6.17. auto
		Tip: 
			用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。
		
		结论：
			auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 
			auto 变量。
			auto 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda
			表达式里。		
	6.18. 列表初始化
		Tip: 你可以用列表初始化。
			 永远别列表初始化 auto 变量。
		
	6.19. lambda表达式
		Tip: 
			适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。
		
		定义：
			Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：
				std::sort(v.begin(), v.end(), [](int x, int y) {
					return Weight(x) < Weight(y);
				});		
		
		结论：
			• 按 标准 小用 lambda 表达式怡情。
			• 禁用默认捕获，捕获都要显式写出来。打比方，比起 [=](int x) {return x + n;}, 您该写成 [n](int x)
			  {return x + n;} 才对，这样读者也好一眼看出 n 是被捕获的值。
			• 匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对
			  象），或改用函数。
			• 如果可读性更好，就显式写出 lambd 的尾置返回类型，就像 auto.		
		
	6.20. 模板编程
		Tip: 不要使用复杂的模板编程
		
		结论:
			• 模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基
			  础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉
			• 在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是
			  否能够读懂并且能够维护你写的模板代码. 或者一个非 c++ 程序员和一些只是在出错的时候偶尔看一下代码的
			  人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元
			  函数, 又或者表达式模板, 或者依赖 SFINAE, 或者 sizeof 的 trick 手段来检查函数是否重载, 那么这说明你模板
			  用的太多了, 这些模板太复杂了, 我们不推荐使用
			• 如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里
			  面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用
			  模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代
			  码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为
			  这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理
			  解, 并且用户很容易知道如何修改这些错误		
		
		
	6.21. Boost库
		Tip: 
			只使用 Boost 中被认可的库
		
		结论:
			为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前
			允许使用以下库: 
				• Call Traits : boost/call_traits.hpp
				• Compressed Pair : boost/compressed_pair.hpp
				• <The Boost Graph Library (BGL) : boost/graph, except serialization (adj_list_serialize.
				hpp) and parallel/distributed algorithms and data structures(boost/graph/parallel/* and boost/
				graph/distributed/*) • Property Map : boost/property_map.hpp
				• The part of Iterator that deals with defining iterators: boost/iterator/iterator_adaptor.hpp,
				boost/iterator/iterator_facade.hpp, and boost/function_output_iterator.hpp
				• The part of Polygon that deals with Voronoi diagram construction and doesn’t depend on the rest
				of Polygon: boost/polygon/voronoi_builder.hpp, boost/polygon/voronoi_diagram.hpp, and
				boost/polygon/voronoi_geometry_type.hpp
				• Bimap : boost/bimap
				• Statistical Distributions and Functions : boost/math/distributions
				• Multi-index : boost/multi_index
				• Heap : boost/heap
				• The flat containers from Container: boost/container/flat_map, and boost/container/flat_set
			
			我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.
			以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：
				• Pointer Container : boost/ptr_container, 改用 std::unique_ptr
				• Array : boost/array.hpp, 改用 std::array		
		
	6.22. C++11
		Tip: 
			适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。
		
		以下特性最好不要用：
			• 尾置返回类型，比如用 auto foo() -> int 代替 int foo(). 为了兼容于现有代码的声明风格。
			• 编译时合数 <ratio>, 因为它涉及一个重模板的接口风格。
			• <cfenv> 和 <fenv.h> 头文件，因为编译器尚不支持。
			• 默认 lambda 捕获。		
		
	6总结：		
		1. 实际上，缺省参数会改变函数签名的前提是改变了它接收的参数数量，比如把 void a() 改成 void a(int b =
		   0), 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这
		   终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。
		2. 此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。
		3. 我还发现 滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。
		4. friend 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部
		   写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 .cc 文件加以定义。
		5. 本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那
		   么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。
		6. 由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，
		   即的数据成员之后，参考声明顺序 。
		7. 对使用 C++ 异常处理应具有怎样的态度？ 非常值得一读。
		8. 注意初始化 const 对象时，必须在初始化的同时值初始化。
		9. 用断言代替无符号整型类型，深有启发。
		10. auto 在涉及迭代器的循环语句里挺常用。
		11. Should the trailing return type syntax style become the default for new C++11 programs? 讨论了 auto 
		   与尾置返回类型一起用的全新编码风格，值得一看。		
		
		
		
		
		
		
		
		
		
		
	